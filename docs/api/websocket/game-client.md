# GameClient

The `GameClient` interface represents a connected client on the GameServer. It contains client state information, WebSocket connection details, and metadata for multiplayer game sessions.

## Interface Definition

```typescript
interface GameClient {
  readonly id: string;
  entityId?: number;
  ws: ServerWebSocket<unknown>;
  lastHeartbeat: number;
  isAuthenticated: boolean;
  metadata: Record<string, unknown>;
}
```

## Properties

### id

```typescript
readonly id: string
```

Unique identifier for the client, automatically generated by the GameServer. Format: `client_{sequence}_{timestamp}`.

#### Example
```typescript
console.log(client.id); // "client_1_1677123456789"
```

### entityId

```typescript
entityId?: number
```

Optional entity ID associated with this client after authentication. When a client authenticates, the server creates a corresponding entity in the ECS World.

#### Example
```typescript
if (client.entityId !== undefined) {
  // Client has an associated entity
  const playerComponent = world.getComponent(client.entityId, 'player');
  console.log(`Player name: ${playerComponent.name}`);
}
```

### ws

```typescript
ws: ServerWebSocket<unknown>
```

The underlying Bun WebSocket connection for this client. Used internally by GameServer for communication.

#### Example
```typescript
// Send message directly (usually done via GameServer methods)
client.ws.send(JSON.stringify(message));

// Check connection state
if (client.ws.readyState === WebSocket.OPEN) {
  console.log('Client connection is active');
}
```

### lastHeartbeat

```typescript
lastHeartbeat: number
```

Timestamp of the last received heartbeat or message from this client. Used for connection timeout detection.

#### Example
```typescript
const now = Date.now();
const timeSinceLastContact = now - client.lastHeartbeat;

if (timeSinceLastContact > 60000) {
  console.log('Client may be disconnected');
}
```

### isAuthenticated

```typescript
isAuthenticated: boolean
```

Authentication status flag. Clients must authenticate before sending game messages.

#### Example
```typescript
if (!client.isAuthenticated) {
  server.sendToClient(client.id, {
    type: 'system',
    timestamp: Date.now(),
    payload: {
      command: 'error',
      data: { message: 'Authentication required' }
    }
  });
}
```

### metadata

```typescript
metadata: Record<string, unknown>
```

Additional client information provided during authentication or session management.

#### Example
```typescript
// Set metadata during authentication
client.metadata = {
  username: 'player123',
  level: 42,
  sessionStartTime: Date.now(),
  region: 'us-west'
};

// Access metadata
console.log(`Player ${client.metadata.username} joined from ${client.metadata.region}`);
```

## Client Lifecycle

### 1. Connection Phase

When a client connects to the GameServer:

```typescript
// Server creates GameClient instance
const client: GameClient = {
  id: generateClientId(),
  ws: websocketConnection,
  lastHeartbeat: Date.now(),
  isAuthenticated: false,
  metadata: {}
};

// Add to server's client map
server.clients.set(client.id, client);
```

### 2. Authentication Phase

```typescript
// Client sends authentication message
{
  type: 'system',
  payload: {
    command: 'authenticate',
    data: {
      username: 'player123',
      token: 'auth_token_here'
    }
  }
}

// Server processes authentication
if (validateAuthToken(authData.token)) {
  client.isAuthenticated = true;
  client.metadata = {
    username: authData.username,
    joinTime: Date.now()
  };

  // Create associated entity
  const entity = world.createEntity();
  client.entityId = entity;
}
```

### 3. Active Phase

During gameplay, the client can send and receive messages:

```typescript
// Client sends input
{
  type: 'input',
  payload: {
    action: 'move',
    data: { direction: 'north', speed: 1.0 }
  }
}

// Server processes and updates client state
client.lastHeartbeat = Date.now();
```

### 4. Disconnection Phase

```typescript
// Server cleans up client resources
if (client.entityId !== undefined) {
  world.destroyEntity(client.entityId);
}

server.clients.delete(client.id);
```

## Client Management Patterns

### Custom Client Metadata

```typescript
class GameServer {
  private enhanceClientMetadata(client: GameClient, authData: any): void {
    client.metadata = {
      ...client.metadata,
      username: authData.username,
      level: authData.level || 1,
      experience: authData.experience || 0,
      lastLoginTime: Date.now(),
      sessionId: generateSessionId(),
      permissions: authData.permissions || ['basic'],

      // Game-specific data
      character: {
        class: authData.characterClass || 'warrior',
        stats: authData.stats || defaultStats
      },

      // Session tracking
      connectionQuality: 'good',
      latency: 0,
      packetsLost: 0
    };
  }
}
```

### Client State Tracking

```typescript
class ClientManager {
  updateClientLatency(clientId: string, latency: number): void {
    const client = server.clients.get(clientId);
    if (client) {
      client.metadata.latency = latency;
      client.metadata.connectionQuality = this.calculateQuality(latency);
    }
  }

  getClientsByRegion(region: string): GameClient[] {
    return Array.from(server.clients.values())
      .filter(client => client.metadata.region === region);
  }

  getActiveClients(): GameClient[] {
    const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
    return Array.from(server.clients.values())
      .filter(client => client.lastHeartbeat > fiveMinutesAgo);
  }
}
```

### Entity-Client Synchronization

```typescript
class PlayerSystem extends BaseSystem {
  update(world: World): void {
    // Sync client data with player entities
    for (const client of server.getConnectedClients()) {
      const clientObj = server.clients.get(client);

      if (clientObj?.entityId && clientObj.isAuthenticated) {
        this.syncClientToEntity(world, clientObj);
      }
    }
  }

  private syncClientToEntity(world: World, client: GameClient): void {
    const entity = client.entityId!;

    // Update player component with client metadata
    const player = world.getComponent(entity, 'player');
    if (player) {
      player.username = client.metadata.username;
      player.level = client.metadata.level;
      player.lastSeen = client.lastHeartbeat;
    }

    // Update network component
    const network = world.getComponent(entity, 'network');
    if (network) {
      network.clientId = client.id;
      network.latency = client.metadata.latency || 0;
      network.isOnline = true;
    }
  }
}
```

## Message Handling Patterns

### Type-Safe Client Messages

```typescript
interface AuthenticatedClient extends GameClient {
  isAuthenticated: true;
  entityId: number;
  metadata: {
    username: string;
    level: number;
    [key: string]: unknown;
  };
}

function isAuthenticatedClient(client: GameClient): client is AuthenticatedClient {
  return client.isAuthenticated && client.entityId !== undefined;
}

// Usage
function processGameMessage(client: GameClient, message: NetworkMessage): void {
  if (!isAuthenticatedClient(client)) {
    server.sendError(client.id, 'Authentication required');
    return;
  }

  // TypeScript knows client is authenticated
  const playerId = client.entityId;
  const username = client.metadata.username;

  handleAuthenticatedMessage(playerId, username, message);
}
```

### Client Message Routing

```typescript
class MessageRouter {
  private routeClientMessage(client: GameClient, message: NetworkMessage): void {
    switch (message.type) {
      case 'input':
        this.handleInputMessage(client, message as InputMessage);
        break;

      case 'event':
        this.handleEventMessage(client, message as EventMessage);
        break;

      case 'system':
        this.handleSystemMessage(client, message as SystemMessage);
        break;

      default:
        server.sendError(client.id, `Unknown message type: ${message.type}`);
    }
  }

  private handleInputMessage(client: GameClient, message: InputMessage): void {
    if (!client.isAuthenticated) return;

    // Emit input event for game systems
    world.emitEvent({
      type: 'player_input',
      timestamp: Date.now(),
      source: client.id,
      data: {
        entityId: client.entityId,
        action: message.payload.action,
        data: message.payload.data
      }
    });
  }
}
```

## Security Considerations

### Client Validation

```typescript
function validateClientMetadata(metadata: Record<string, unknown>): boolean {
  // Validate username
  if (typeof metadata.username !== 'string' ||
      metadata.username.length > 50) {
    return false;
  }

  // Validate level
  if (typeof metadata.level !== 'number' ||
      metadata.level < 1 || metadata.level > 100) {
    return false;
  }

  return true;
}
```

### Rate Limiting per Client

```typescript
class ClientRateLimiter {
  private clientLimits = new Map<string, { count: number; resetTime: number }>();

  checkRateLimit(clientId: string, maxRequests: number, windowMs: number): boolean {
    const now = Date.now();
    const limit = this.clientLimits.get(clientId);

    if (!limit || now > limit.resetTime) {
      this.clientLimits.set(clientId, { count: 1, resetTime: now + windowMs });
      return true;
    }

    if (limit.count >= maxRequests) {
      return false; // Rate limit exceeded
    }

    limit.count++;
    return true;
  }
}
```

## Performance Optimization

### Client Batch Operations

```typescript
function broadcastToClientSubset(
  clients: GameClient[],
  message: NetworkMessage,
  predicate: (client: GameClient) => boolean
): void {
  const serialized = MessageSerializer.serialize(message);

  for (const client of clients) {
    if (predicate(client)) {
      try {
        client.ws.send(serialized);
      } catch (error) {
        console.warn(`Failed to send to client ${client.id}`);
      }
    }
  }
}

// Usage: broadcast only to authenticated clients in same region
broadcastToClientSubset(
  Array.from(server.clients.values()),
  gameStateMessage,
  client => client.isAuthenticated && client.metadata.region === 'us-west'
);
```

### Memory Management

```typescript
class ClientCleanup {
  cleanupDisconnectedClients(): void {
    const timeout = 60000; // 1 minute
    const cutoff = Date.now() - timeout;

    for (const [clientId, client] of server.clients) {
      if (client.lastHeartbeat < cutoff) {
        this.removeClient(clientId);
      }
    }
  }

  private removeClient(clientId: string): void {
    const client = server.clients.get(clientId);
    if (client?.entityId) {
      world.destroyEntity(client.entityId);
    }
    server.clients.delete(clientId);
  }
}
```

## Testing Client Interactions

```typescript
describe('GameClient Integration', () => {
  test('should authenticate client and create entity', () => {
    const world = new World();
    const server = new GameServer(world);

    // Mock client connection
    const mockWs = createMockWebSocket();
    const client: GameClient = {
      id: 'test_client',
      ws: mockWs,
      lastHeartbeat: Date.now(),
      isAuthenticated: false,
      metadata: {}
    };

    // Process authentication
    server.handleSystemMessage(client, {
      type: 'system',
      timestamp: Date.now(),
      payload: {
        command: 'authenticate',
        data: { username: 'testplayer' }
      }
    });

    expect(client.isAuthenticated).toBe(true);
    expect(client.entityId).toBeDefined();
    expect(client.metadata.username).toBe('testplayer');
  });
});
```

## See Also

- [GameServer](./game-server.md) - Server management and client handling
- [NetworkMessage](./network-message.md) - Message format specification
- [MessageSerializer](./message-serializer.md) - Message serialization utilities
- [World](../core/world.md) - ECS World integration